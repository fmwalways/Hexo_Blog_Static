<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux 防火墙端口设置</title>
    <link href="/2019/06/21/Linux-%E9%98%B2%E7%81%AB%E5%A2%99%E7%AB%AF%E5%8F%A3%E8%AE%BE%E7%BD%AE/"/>
    <url>/2019/06/21/Linux-%E9%98%B2%E7%81%AB%E5%A2%99%E7%AB%AF%E5%8F%A3%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h2><p><strong>CentOS 7</strong>、<strong>RedHat 7</strong> 之前的 <strong>Linux</strong> 发行版防火墙设置</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#开启</span><br>service iptables <span class="hljs-literal">start</span><br><span class="hljs-comment">#关闭</span><br>service iptables <span class="hljs-literal">stop</span><br></code></pre></td></tr></table></figure><p>加入开机启动</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#开启</span><br><span class="hljs-attribute">chkconfig</span> iptables <span class="hljs-literal">on</span><br><span class="hljs-comment">#关闭</span><br>chkconfig iptables <span class="hljs-literal">off</span><br></code></pre></td></tr></table></figure><p><strong>CentOS 7</strong>、<strong>RedHat 7</strong> 之后的 <strong>Linux</strong> 发行版防火墙设置</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean">##开启<br>systemctl start firewalld.service<br>##关闭<br>systemctl stop firewalld.service<br></code></pre></td></tr></table></figure><h2 id="端口设置"><a href="#端口设置" class="headerlink" title="端口设置"></a>端口设置</h2><p><strong>CentOS 7</strong>、<strong>RedHat 7</strong> 之前的 <strong>Linux</strong> 发行版端口设置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#开启27017端口接收数据</span><br><span class="hljs-regexp">/sbin/i</span>ptables -I INPUT -p tcp --dport <span class="hljs-number">27017</span> -j ACCEPT<br><span class="hljs-comment">#开启27017端口发送数据</span><br><span class="hljs-regexp">/sbin/i</span>ptables -I OUTPUT -p tcp --dport <span class="hljs-number">27017</span> -j ACCEPT<br><span class="hljs-comment">#查找所有规则</span><br><span class="hljs-regexp">/sbin/i</span>ptables -L INPUT --line-numbers<br><span class="hljs-comment">#删除一条规则</span><br><span class="hljs-regexp">/sbin/i</span>ptables -D INPUT <span class="hljs-number">3</span>  (<span class="hljs-number">3</span>是规则中的行号)<br><span class="hljs-comment">#保存配置</span><br><span class="hljs-regexp">/etc/</span>rc.d<span class="hljs-regexp">/init.d/i</span>ptables save<br><span class="hljs-comment">#重启防火墙服务</span><br><span class="hljs-regexp">/etc/</span>rc.d<span class="hljs-regexp">/init.d/i</span>ptables restart<br><span class="hljs-comment">#查看是否开启成功</span><br><span class="hljs-regexp">/etc/i</span>nit.d/iptables status<br></code></pre></td></tr></table></figure><p><strong>CentOS 7</strong>、<strong>RedHat 7</strong>之后的 <strong>Linux</strong> 发行版端口设置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># --zone 作用域</span><br><span class="hljs-comment"># --add-port=27017/tcp 添加端口，格式为：端口/通讯协议</span><br><span class="hljs-comment"># --remove-port=27017/tcp 移除端口，格式为：端口/通讯协议</span><br><span class="hljs-comment"># --permanent 永久生效，没有此参数重启后失效</span><br>firewall-cmd <span class="hljs-attribute">--zone</span>=public <span class="hljs-attribute">--add-port</span>=27017/tcp --permanent<br>firewall-cmd <span class="hljs-attribute">--zone</span>=public <span class="hljs-attribute">--remove-port</span>=27017/tcp --permanent<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>端口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter入门之MacOS 开发环境搭建</title>
    <link href="/2019/06/19/Flutter%E5%85%A5%E9%97%A8%E4%B9%8BMacOS-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2019/06/19/Flutter%E5%85%A5%E9%97%A8%E4%B9%8BMacOS-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>距离上一次谷歌开发者大会已经过去了两个月的时间，大会上推出了<strong>Android Q</strong>、<strong>Flutter Web</strong>开发支持以及一些其他方面的东西，作为<strong>Android</strong>开发出身的我<strong>Flutter</strong>产生了极为浓厚的兴趣，<strong>Dart</strong>语言作为<strong>Flutter</strong>开发语言，让我对同样采用此语言<strong>Google</strong>为了万物互联开发的<strong>Fuchsia</strong>系统也充满了期待，于是在空闲时间就开始了此番环境的部署。</p><span id="more"></span><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ol><li>获取Flutter SDK</li><li>添加环境变量</li><li>完成Flutter依赖配置</li><li>新建安装Flutter项目</li></ol><h1 id="1-获取Flutter-SDK"><a href="#1-获取Flutter-SDK" class="headerlink" title="1. 获取Flutter SDK"></a>1. 获取Flutter SDK</h1><p>在<strong>Flutter</strong>官网下载当前平台可用的安装包，我在<strong>Mac</strong>环境下载的是Mac的安装包。 <a href="https://flutter.dev/docs/development/tools/sdk/releases">官网下载链接</a></p><p>请根据当前平台下载合适的安装包，如果官网链接不可用可以去<strong>Flutter GitHub</strong>项目下载。<a href="https://github.com/flutter/flutter/releases">GitHub下载链接</a></p><h1 id="2-添加环境变量"><a href="#2-添加环境变量" class="headerlink" title="2. 添加环境变量"></a>2. 添加环境变量</h1><p>解压刚才下载好的安装包并且移动到合适的位置，然后添加<strong>Flutter SDK</strong>环境变量以使用<strong>flutter</strong>命令行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=`Flutter_DIR`/bin:$PATH<br></code></pre></td></tr></table></figure><p>其中<strong>Flutter_DIR</strong>为<strong>Flutter SDK</strong>所在的文件夹路径，由于众所周知的原因，<strong>Flutter</strong>依赖包服务在中国大陆地区的服务可能不可用，大家也可以添加以下环境变量添加国内镜像源</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">PUB_HOSTED_URL</span>=https://pub.flutter-io.cn<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">FLUTTER_STORAGE_BASE_URL</span>=https://storage.flutter-io.cn<br></code></pre></td></tr></table></figure><p>更改了环境变量文件之后可能需要重启或者注销一下计算机，非即时生效。</p><h1 id="3-完成Flutter-依赖配置"><a href="#3-完成Flutter-依赖配置" class="headerlink" title="3. 完成Flutter 依赖配置"></a>3. 完成Flutter 依赖配置</h1><p>如果上面一切正常的话就可以使用<strong>flutter</strong>命令行了，我们可以使用以下命令检查我们的依赖项是否安装完成。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">flutter doctor</span><br></code></pre></td></tr></table></figure><p>如果你像我一样需要同时在<strong>iOS</strong>和<strong>Android</strong>平台开发，那么就要同时装<strong>AndroidStudio</strong>和<strong>XCode</strong>，如果仅仅开发<strong>Android</strong>平台，那么<strong>AndroidStudio</strong>就够了。运行刚才的命令可能会报错，排错还是挺简单的根据提示的内容逐个解决就行了，在这里就不一一赘述。所有依赖成功安装后的提示信息如下。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[✓]</span> Flutter (Channel stable, v1.<span class="hljs-number">5.4</span>-hotfix.<span class="hljs-number">2</span>, on Mac OS X <span class="hljs-number">10.14</span>.<span class="hljs-number">5</span> <span class="hljs-number">18</span>F132, locale zh-Hans-CN)<br><span class="hljs-selector-attr">[✓]</span> Android toolchain - develop for Android devices (Android SDK version <span class="hljs-number">28.0</span>.<span class="hljs-number">3</span>)<br><span class="hljs-selector-attr">[✓]</span> iOS toolchain - develop for iOS devices (Xcode <span class="hljs-number">10.2</span>.<span class="hljs-number">1</span>)<br><span class="hljs-selector-attr">[✓]</span> Android Studio (version <span class="hljs-number">3.4</span>)<br><span class="hljs-selector-attr">[✓]</span> Connected device (<span class="hljs-number">1</span> available)<br></code></pre></td></tr></table></figure><h1 id="4-新建安装Flutter项目"><a href="#4-新建安装Flutter项目" class="headerlink" title="4. 新建安装Flutter项目"></a>4. 新建安装Flutter项目</h1><p>在合适的文件夹运行以下命令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">flutter create flutter_app</span><br></code></pre></td></tr></table></figure><p>就能创建一个名字为<strong>flutter_app</strong>的<strong>flutter</strong>项目，<br>这个时候我们插上手机打开<strong>USB</strong>调试或者打开<strong>iOS</strong>、<strong>Android</strong>模拟器运行以下命令行</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">flutter devices</span><br></code></pre></td></tr></table></figure><p>如果到类似如下结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span> connected devices:<br><br><span class="hljs-attribute">Android</span> SDK built for x86 • emulator-<span class="hljs-number">5554</span>       • android-x86 • Android <span class="hljs-number">9</span> (API <span class="hljs-number">28</span>) (emulator)<br><span class="hljs-attribute">iPhone</span> Xs                 • <span class="hljs-number">7</span>E13B417 • ios      • com.apple.CoreSimulator.SimRuntime.iOS-<span class="hljs-number">12</span>-<span class="hljs-number">2</span>(simulator)<br></code></pre></td></tr></table></figure><p>说明手机或者模拟器连接正常，如果没有设备请检查手机连接。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">flutter <span class="hljs-built_in">run</span><br></code></pre></td></tr></table></figure><p>最后我们通过命令行<strong>cd</strong>进入<strong>flutter_app</strong>文件夹，使用<strong>run</strong>命令就可以将<strong>flutter</strong>应用编译在<strong>Android</strong>或者<strong>iOS</strong>设备当中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Flutter</tag>
      
      <tag>MacOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修复Windows Linux 双系统时间差</title>
    <link href="/2019/05/10/%E4%BF%AE%E5%A4%8DWindows-Linux-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%B7%AE/"/>
    <url>/2019/05/10/%E4%BF%AE%E5%A4%8DWindows-Linux-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%B7%AE/</url>
    
    <content type="html"><![CDATA[<p>装了双系统之后启动Windows后会有8个小时的时间差（北京时区），这是因为Linux在开机时候写入主板的时间的是有时区的时间，Windows开机后直接拿来用不包含时区，就造成了时间差。</p><span id="more"></span><h2 id="1-Windows修复方式"><a href="#1-Windows修复方式" class="headerlink" title="1. Windows修复方式"></a>1. Windows修复方式</h2><p>打开注册表</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\<br></code></pre></td></tr></table></figure><p>下面增加一个名为 RealTimeIsUniversal 的 REG_DWORD 键，并赋值为1。</p><h2 id="2-Linux修复方式"><a href="#2-Linux修复方式" class="headerlink" title="2. Linux修复方式"></a>2. Linux修复方式</h2><p>在终端中输入以下指令</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sudo apt-get install ntpdate<br>sudo ntpdate <span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.windows</span><span class="hljs-selector-class">.com</span><br>sudo hwclock <span class="hljs-attr">--localtime</span> <span class="hljs-attr">--systohc</span><br></code></pre></td></tr></table></figure><p>现在来回切换系统时间正常。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Windows</tag>
      
      <tag>双系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>申请 Let&#39;s Encrypt 通配符Https证书</title>
    <link href="/2019/05/09/%E7%94%B3%E8%AF%B7-Let-s-Encrypt-%E9%80%9A%E9%85%8D%E7%AC%A6htps%E8%AF%81%E4%B9%A6/"/>
    <url>/2019/05/09/%E7%94%B3%E8%AF%B7-Let-s-Encrypt-%E9%80%9A%E9%85%8D%E7%AC%A6htps%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<p>之前忘记续费的域名结果被别人抢注了，无奈申请了cn后缀的域名，利用零零星星的时间还是把博客搭建起来了。之前搭建好了之后一直没有经历去维护他，以后应该会抽空维护下去了，可能不光光是技术性的东西，个人生活也会记录在这上边。闲话不多说，让我们开始此文的主题吧。</p><span id="more"></span><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>域名和服务都搭建完成了，就想着搞全站Https，之前用的是DNS托管的形式，灵活性较差，加上Let’s Encrypt可以申请通配符的免费证书，于是就迁移了过来，使用到的工具是<strong>acme.sh</strong> ，<strong>acme.sh</strong> 实现了 <code>acme</code> 协议, 可以从 letsencrypt 生成免费的证书，省去了需要手动修改的繁琐。</p><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ol><li>安装 <strong>acme.sh</strong></li><li>生成证书</li><li>copy 证书到 nginx/apache 或者其他服务</li><li>更新证书</li><li>更新 <strong>acme.sh</strong></li><li>出错怎么办, 如何调试</li></ol><h1 id="1-安装-acme-sh"><a href="#1-安装-acme-sh" class="headerlink" title="1. 安装 acme.sh"></a>1. 安装 <strong>acme.sh</strong></h1><p>安装很简单, 一个命令:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">curl  https://<span class="hljs-built_in">get</span>.acme.<span class="hljs-keyword">sh</span> | <span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><p>普通用户和 root 用户都可以安装使用.<br>安装过程进行了以下几步:</p><ol><li>把 acme.sh 安装到你的 <strong>home</strong> 目录下:</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">~<span class="hljs-regexp">/.acme.sh/</span><br></code></pre></td></tr></table></figure><p>并创建 一个 bash 的 alias, 方便你的使用:  <code>alias acme.sh=~/.acme.sh/acme.sh</code></p><p>2). 自动为你创建 cronjob,  每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书.</p><p>更高级的安装选项请参考: <a href="https://github.com/Neilpang/acme.sh/wiki/How-to-install">https://github.com/Neilpang/acme.sh/wiki/How-to-install</a></p><p><strong>安装过程不会污染已有的系统任何功能和文件</strong>, 所有的修改都限制在安装目录中: <code>~/.acme.sh/</code></p><h1 id="2-生成证书"><a href="#2-生成证书" class="headerlink" title="2. 生成证书"></a>2. 生成证书</h1><p><strong>acme.sh</strong> 实现了 <strong>acme</strong> 协议支持的所有验证协议.<br>一般有两种方式验证: http 和 dns 验证.</p><h3 id="1-http-方式"><a href="#1-http-方式" class="headerlink" title="1. http 方式"></a>1. http 方式</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span>  <span class="hljs-attr">--issue</span>  -d mydomain<span class="hljs-selector-class">.com</span> -d www<span class="hljs-selector-class">.mydomain</span><span class="hljs-selector-class">.com</span>  <span class="hljs-attr">--webroot</span>  /home/wwwroot/mydomain.com/<br></code></pre></td></tr></table></figure><p>只需要指定域名, 并指定域名所在的网站根目录. <strong>acme.sh</strong> 会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证. 最后会聪明的删除验证文件. 整个过程没有任何副作用. </p><p>如果你用的 <strong>apache</strong>服务器, <strong>acme.sh</strong> 还可以智能的从 <strong>apache</strong>的配置中自动完成验证, 你不需要指定网站根目录:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--issue</span>  -d mydomain<span class="hljs-selector-class">.com</span>   <span class="hljs-attr">--apache</span><br></code></pre></td></tr></table></figure><p>如果你用的 <strong>nginx</strong>服务器, 或者反代, <strong>acme.sh</strong> 还可以智能的从 <strong>nginx</strong>的配置中自动完成验证, 你不需要指定网站根目录:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--issue</span>  -d mydomain<span class="hljs-selector-class">.com</span>   <span class="hljs-attr">--nginx</span><br></code></pre></td></tr></table></figure><p><strong>注意, 无论是 apache 还是 nginx 模式, acme.sh在完成验证之后, 会恢复到之前的状态, 都不会私自更改你本身的配置. 好处是你不用担心配置被搞坏, 也有一个缺点, 你需要自己配置 ssl 的配置, 否则只能成功生成证书, 你的网站还是无法访问https. 但是为了安全, 你还是自己手动改配置吧.</strong></p><p>如果你还没有运行任何 web 服务, <strong>80</strong> 端口是空闲的, 那么 <strong>acme.sh</strong> 还能假装自己是一个webserver, 临时听在<strong>80</strong> 端口, 完成验证:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span>  <span class="hljs-attr">--issue</span> -d mydomain<span class="hljs-selector-class">.com</span>   <span class="hljs-attr">--standalone</span><br></code></pre></td></tr></table></figure><p>更高级的用法请参考: <a href="https://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert">https://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert</a></p><h3 id="2-dns-方式"><a href="#2-dns-方式" class="headerlink" title="2. dns 方式"></a>2. dns 方式</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span>  <span class="hljs-attr">--issue</span>  <span class="hljs-attr">--dns</span>   -d mydomain.com<br></code></pre></td></tr></table></figure><p>这种方式的好处是, 你不需要任何服务器, 不需要任何公网 ip, 只需要 dns 的解析记录即可完成验证.<br>坏处是，如果不同时配置 Automatic DNS API，使用这种方式 acme.sh 将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。<br>然后, <strong>acme.sh</strong> 会生成相应的解析记录显示出来, 你只需要在你的域名管理面板中添加这条 txt 记录即可。</p><p>等待解析完成之后, 重新生成证书:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span>  <span class="hljs-attr">--renew</span>   -d mydomain.com<br></code></pre></td></tr></table></figure><p>注意第二次这里用的是 <code>--renew</code></p><p>dns 方式的真正强大之处在于可以使用域名解析商提供的 api 自动添加 txt 记录完成验证.</p><p><strong>acme.sh</strong> 目前支持 cloudflare, dnspod, cloudxns, godaddy 以及 ovh 等数十种解析商的自动集成. </p><p>以 dnspod 为例, 你需要先登录到 dnspod 账号, 生成你的 api id 和 api key, 都是免费的.<br>然后:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">DP_Id</span>=<span class="hljs-string">&quot;1234&quot;</span><br><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">DP_Key</span>=<span class="hljs-string">&quot;sADDsdasdgdsf&quot;</span><br><br>acme.sh   --issue   --dns dns_dp   -d aa.com  -d www.aa.com<br><br></code></pre></td></tr></table></figure><p>证书就会自动生成了. 这里给出的 api id 和 api key 会被自动记录下来, 将来你在使用 dnspod api 的时候, 就不需要再次指定了.<br>直接生成就好了:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span>  <span class="hljs-attr">--issue</span>   -d  mydomain2<span class="hljs-selector-class">.com</span>   <span class="hljs-attr">--dns</span>  dns_dp<br></code></pre></td></tr></table></figure><p>更详细的 api 用法: <a href="https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md">https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md</a></p><h1 id="3-copy-安装-证书"><a href="#3-copy-安装-证书" class="headerlink" title="3. copy/安装 证书"></a>3. copy/安装 证书</h1><p>前面证书生成以后, 接下来需要把证书 copy 到真正需要用它的地方.</p><p>注意, 默认生成的证书都放在安装目录下: <code>~/.acme.sh/</code>,  请不要直接使用此目录下的文件, 例如: 不要直接让 nginx/apache 的配置文件使用这下面的文件. 这里面的文件都是内部使用, 而且目录结构可能会变化.</p><p>正确的使用方法是使用 <code>--installcert</code> 命令,并指定目标位置, 然后证书文件会被copy到相应的位置,<br>例如:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">acme.sh  --installcert  -d  &lt;domain&gt;.com   \<br>        --key-<span class="hljs-keyword">file</span>   <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/ssl/</span>&lt;domain&gt;.key \<br>        --fullchain-<span class="hljs-keyword">file</span> <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/ssl/</span>fullchain.cer \<br>        --reloadcmd  <span class="hljs-string">&quot;service nginx force-reload&quot;</span><br></code></pre></td></tr></table></figure><p>(一个小提醒, 这里用的是 <code>service nginx force-reload</code>, 不是 <code>service nginx reload</code>, 据测试, <code>reload</code> 并不会重新加载证书, 所以用的 <code>force-reload</code>)</p><p>Nginx 的配置 <code>ssl_certificate</code> 使用 <code>/etc/nginx/ssl/fullchain.cer</code> ，而非 <code>/etc/nginx/ssl/&lt;domain&gt;.cer</code> ，否则 <a href="https://www.ssllabs.com/ssltest/">SSL Labs</a> 的测试会报 <code>Chain issues Incomplete</code> 错误。</p><p><code>--installcert</code>命令可以携带很多参数, 来指定目标文件.  并且可以指定 reloadcmd, 当证书更新以后, reloadcmd会被自动调用,让服务器生效.</p><p>详细参数请参考: <a href="https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc">https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc</a></p><p>值得注意的是, 这里指定的所有参数都会被自动记录下来, 并在将来证书自动更新以后, 被再次自动调用.</p><h1 id="4-更新证书"><a href="#4-更新证书" class="headerlink" title="4. 更新证书"></a>4. 更新证书</h1><p>目前证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心.</p><h1 id="5-更新-acme-sh"><a href="#5-更新-acme-sh" class="headerlink" title="5. 更新 acme.sh"></a>5. 更新 acme.sh</h1><p>目前由于 acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh 也经常更新以保持同步. </p><p>升级 acme.sh 到最新版 :</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--upgrade</span><br></code></pre></td></tr></table></figure><p>如果你不想手动升级, 可以开启自动升级:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span>  <span class="hljs-attr">--upgrade</span>  <span class="hljs-attr">--auto-upgrade</span><br></code></pre></td></tr></table></figure><p>之后, acme.sh 就会自动保持更新了.</p><p>你也可以随时关闭自动更新:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">acme<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--upgrade</span>  <span class="hljs-attr">--auto-upgrade</span>  <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="6-出错怎么办："><a href="#6-出错怎么办：" class="headerlink" title="6. 出错怎么办："></a>6. 出错怎么办：</h1><p>如果出错, 请添加 debug log：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">acme.sh  <span class="hljs-params">--issue</span>  <span class="hljs-string">.....</span>  <span class="hljs-params">--debug</span> <br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">acme.sh  <span class="hljs-params">--issue</span>  <span class="hljs-string">.....</span>  <span class="hljs-params">--debug</span>  2<br></code></pre></td></tr></table></figure><p>请参考： <a href="https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh">https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh</a></p><p>最后, 本文并非完全的使用说明, 还有很多高级的功能, 更高级的用法请参看其他 wiki 页面.</p><p><a href="https://github.com/Neilpang/acme.sh/wiki">https://github.com/Neilpang/acme.sh/wiki</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>https</tag>
      
      <tag>域名</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub pages 搭建Hexo博客教程</title>
    <link href="/2017/08/18/GitHub-pages-%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    <url>/2017/08/18/GitHub-pages-%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>之前买的服务器到期了，每个月续费感觉有点麻烦，索性就用了Github pages搭建Hexo博客，有考虑过用oschina的pages而且oschina上面可以创建私有仓库，但找了好久没有看到CHAME服务，这个想法也就做罢了。</p><span id="more"></span><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><ul><li>Node.js环境配置</li><li>Github的账户配置</li><li>Hexo环境配置</li></ul><h3 id="配置Node-js"><a href="#配置Node-js" class="headerlink" title="配置Node.js"></a>配置Node.js</h3><p>  1.下载node.js<br>      <a href="https://nodejs.org/dist/v8.4.0/node-v8.4.0-x86.msi">Windows installer 32-bit</a><br>      <a href="https://nodejs.org/dist/v8.4.0/node-v8.4.0-x64.msi">Windows installer 64-bit</a><br>这里提供了Windows平台的快捷下载，下载其他版本的Node.js<a href="https://nodejs.org/zh-cn/download/current/">点此</a></p><p>  2.下载完成之后就可以安装了，如果不需要更改安装目录的话，一路Next就可以了，最后我们通过命令行检查一下是否安装成功。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">node</span> -v<br><span class="hljs-attribute">v6</span>.<span class="hljs-number">9</span>.<span class="hljs-number">5</span><br><br><span class="hljs-attribute">npm</span> -v<br><span class="hljs-attribute">3</span>.<span class="hljs-number">10</span>.<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="Git的安装和账户配置"><a href="#Git的安装和账户配置" class="headerlink" title="Git的安装和账户配置"></a>Git的安装和账户配置</h3><p>1.首先下载Git安装：<br><a href="https://git-scm.com/downloads">Git官网下载</a><br>安装过程不再详述，基本上就是Next就可以了。最后我们检查一下安装是否成功。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> --version<br><span class="hljs-attribute">git</span> version <span class="hljs-number">2</span>.<span class="hljs-number">13</span>.<span class="hljs-number">0</span>.windows.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>2.Git 账户配置：<br>如果没有Github账号先去注册账号 <a href="https://github.com/">GitHub</a><br>创建代码库<br><img src="https://raw.githubusercontent.com/fmwalways/Hexo_Res/master/20170818230706.png"></p><p>注意：如果你想用yourname.github.io这种类型的域名，你在创建仓库的名称的时候就该这样命名yourname.github.io，否则GitHub会给你生成一个yourname.github.io/projectname的地址<br><img src="https://raw.githubusercontent.com/fmwalways/Hexo_Res/master/20170818232507.png"></p><p>仓库创建好以后我们就去项目主页中的Setting中找到GitHub Pages Source选项选择master branch 点击save</p><p><img src="https://raw.githubusercontent.com/fmwalways/Hexo_Res/master/20170818234302.png"></p><p><img src="https://raw.githubusercontent.com/fmwalways/Hexo_Res/master/20170818234329.png"></p><p>如果配置没有问题的话我们这个时候yourname.github.io 应该就可以访问了，可能需要15分钟左右。此时我们的GitHub环境已经配置完毕。</p><h3 id="Hexo环境配置"><a href="#Hexo环境配置" class="headerlink" title="Hexo环境配置"></a>Hexo环境配置</h3><p>命令行执行以下两条命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> hexo-cli -g<br>npm <span class="hljs-keyword">install</span> hexo --save<br></code></pre></td></tr></table></figure><p>检查是否安装成功</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo -v</span><br></code></pre></td></tr></table></figure><h2 id="Hexo部署"><a href="#Hexo部署" class="headerlink" title="Hexo部署"></a>Hexo部署</h2><p>新建文件夹指定Hexo的编译目录，在此目录执行命令</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>然后修改_config.yml中的deploy配置文件和我们的github关联起来</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/username(注意修改)/username(注意修改).github.io.git</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p>把博客编译成静态文件</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure><p>部署博客到我们的Github上</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>如果一切正常的话，我们访问yourname.github.io就可以看到我们的博客已经部署到github上了，我们修改文件后只需要重复运行g命令和d命令就可以上传编译后的文件了，Hexo的使用与修改不再详述。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GitHub pages</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客搭建以及爬坑过程</title>
    <link href="/2017/02/13/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E7%88%AC%E5%9D%91%E8%BF%87%E7%A8%8B/"/>
    <url>/2017/02/13/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E7%88%AC%E5%9D%91%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>此篇博客讲述了我从构想搭建博客以及搭建过程中遇到的问题以及爬坑教程</p><span id="more"></span><h4 id="一、构想和规划"><a href="#一、构想和规划" class="headerlink" title="一、构想和规划"></a>一、构想和规划</h4><p>大概16年11月份时候，那个时候在找工作，平常的时候就写一些代码什么的，在网上翻录别人博客的时候心里就在想什么时候能有个自己私人的博客，这个想法越来越不可收拾，心里一想，那就搞呗。于是乎这篇博文就这样诞生了。大概前前后后历经3个月的时间吧，从服务器到域名，由于用的国内的域名以及DNS，免不了备案一番，其实真正花在这个时间也不多，总的算下来也就几天的时间。停摆一阵弄一阵，看到现在的多域名全站https的博客，回头过来不免感慨一番，现在想想还是挺有意思的一件事情。</p><h4 id="二、服务器的选择"><a href="#二、服务器的选择" class="headerlink" title="二、服务器的选择"></a>二、服务器的选择</h4><p>一开始选择服务器的时候自己没有想那么多，就想着省事能用就行，基于这样的想法就想着用国内的服务器就行了，后面的备案着实的坑了我一下。当时什么也不懂，觉得阿里的服务器挺好，加上新会员优惠活动，就入手了阿里的云服务器。入手之后就考虑域名的问题了，后来一想，既然搞了就搞一起吧，就在万网买了2个域名。</p><h4 id="三、开始搭建博客"><a href="#三、开始搭建博客" class="headerlink" title="三、开始搭建博客"></a>三、开始搭建博客</h4><p>之前采用的方案是httpd + wordpress的方式搭建了一个博客，达不到想要的效果，现在采用的方式是nginx + Hexo 没有启动Hexo服务，仅仅把Hexo生成的静态目录文件部署到nginx目录当中，Windows上编辑markdown文件push到git仓库触发服务器上面的钩子达到自动同步编译的过程，这个后面会讲到。</p><p>OK，Lest’s Begin~ 本次教程服务器系统环境为Centos6.5，客户端系统为Win10</p><ul><li>安装node.js</li></ul><p>此环境Windows也需安装部署</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> -y nodejs<br><br></code></pre></td></tr></table></figure><p>测试是否安装成功</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@iZuf6g6ve7f9a6w9suivvjZ</span> ~]<span class="hljs-meta">#node -v</span><br>v4<span class="hljs-number">.7</span><span class="hljs-number">.2</span><br>[root<span class="hljs-symbol">@iZuf6g6ve7f9a6w9suivvjZ</span> ~]<span class="hljs-meta">#npm -v</span><br><span class="hljs-number">2.15</span><span class="hljs-number">.11</span><br><br></code></pre></td></tr></table></figure><ul><li><p>Windows部署Hexo环境</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install hexo-<span class="hljs-keyword">cli</span> -g<br><br></code></pre></td></tr></table></figure></li><li><p>生成本地Hexo项目</p></li></ul><p>在客户端新建Blog文件夹，初始化Hexo项目并安装拓展，检查是否成功</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">hexo init <span class="hljs-keyword">blog</span><br><span class="hljs-keyword"></span>cd <span class="hljs-keyword">blog</span><br><span class="hljs-keyword"></span>npm <span class="hljs-keyword">install</span><br><span class="hljs-keyword"></span>hexo server<br></code></pre></td></tr></table></figure><p>如果没有问题，可在客户端打开localhost:4000查看效果</p><ul><li>新建一篇文章<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;My First Post&quot;</span><br>hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure></li></ul><p>在/source/_posts目录中生成了刚才文件名的md文件，我们写博客就编辑这个文件，写完了编译即可。</p><ul><li>提交代码托管</li></ul><p>因为GitHub私人项目需要收费，我使用的是国内的<a href="https://coding.net/">Coding.net</a>，新建一个Hexo项目，配置ssh公钥和私钥，使用SSH地址提交代码比较方便一些，服务器需要配置Git，Nignx，安装这两个比较容易，不再赘述。<br>将客户端Hexo目录提交到Git仓库</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Git init<br>Git remote <span class="hljs-built_in">add</span> origin git@git.coding.net:fmwcn/Hexo_Blog.git<br>Git <span class="hljs-built_in">add</span> .<br>Git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>Git push origin master<br></code></pre></td></tr></table></figure><ul><li>服务器拉取仓库代码</li></ul><p>服务器也需要配置ssh才能使用ssh地址，在这里我直接放进根目录</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mkdir hexo<br>git init<br>git remote add origin git@git<span class="hljs-selector-class">.coding</span><span class="hljs-selector-class">.net</span>:fmwcn/Hexo_Blog<span class="hljs-selector-class">.git</span><br>git pull origin master<br></code></pre></td></tr></table></figure><ul><li>Centos部署Hexo<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/hexo<br>npm install hexo-cli -g<br>npm install<br></code></pre></td></tr></table></figure></li><li>Hexo静态编译<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure></li></ul><p>会在hexo目录中生成public目录，只需要将此目录放进nginx目录中就可以了</p><ul><li>GitWebHooks自动化部署</li></ul><p>现在的流程是，我们在客户端写好文件，登陆服务器git pull然后编译一下，如何完成我们的自动化部署呢？<br>Git仓库为我们提供了WebHooks来监控我们的仓库状态，这样我们可以设置当我们客户端Push的时候就会触发我们设定的事件。<br>实现WebHooks自动化部署的推荐条件：<br>服务器端配置ssh认证<br>服务器端配置nodejs服务，接收Coding发来的请求</p><ul><li>配置WebHooks</li></ul><p><img src="https://raw.githubusercontent.com/fmwalways/Hexo_Res/master/20170213211059.png"></p><p>如图所示：当仓库发生push的时候，会发送一个http请求<a href="http://fomav.com:4002/webhooks/push/master">http://fomav.com:4002/webhooks/push/master</a>，我们在服务器处理这个请求就可以了。</p><p>在hexo目录中新建webhooks.js文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-selector-tag">var</span> exec = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>)<span class="hljs-selector-class">.exec</span><br><br>http<span class="hljs-selector-class">.createServer</span>(function (req, res) &#123;<br><span class="hljs-comment">// 该路径与WebHooks中的路径部分需要完全匹配，实现简易的授权认证。</span><br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(req.url === <span class="hljs-string">&#x27;/webhooks/push/master&#x27;</span>)</span></span>&#123;<br><span class="hljs-comment">// 如果url匹配，表示认证通过，则执行 sh ./deploy.sh</span><br><span class="hljs-function"><span class="hljs-title">exec</span><span class="hljs-params">(<span class="hljs-string">&#x27;sh ./deploy.sh&#x27;</span>)</span></span><br>&#125;<br>res<span class="hljs-selector-class">.end</span>()<br>&#125;)<span class="hljs-selector-class">.listen</span>(<span class="hljs-number">4002</span>)<br><br></code></pre></td></tr></table></figure><p>新建一个deploy.sh脚本</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git pull origin <span class="hljs-keyword">master</span><br><span class="hljs-title">hexo</span> g<br></code></pre></td></tr></table></figure><p>安装pm2</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g pm2<br>pm2 start webhooks.js<br></code></pre></td></tr></table></figure><p>至此客户端push文章的时候服务器就会自动部署。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
